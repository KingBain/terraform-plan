{"version":3,"file":"index.js","mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzFA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":[".././src/action.js",".././src/command.js",".././src/github.js",".././src/opa.js","../../../../../usr/local/Cellar/ncc/0.38.1/libexec/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../external node-commonjs \"child_process\"","../external node-commonjs \"fs\"","../webpack/bootstrap","../webpack/runtime/compat",".././src/index.js"],"sourcesContent":["\"use strict\";\n\nconst fs = require(\"fs\");\nconst core = require(\"@actions/core\");\nconst github = require(\"@actions/github\");\nconst { execCommand } = require(\"./command.js\");\nconst { addComment, deleteComment } = require(\"./github.js\");\nconst { getPlanChanges } = require(\"./opa.js\");\n\nfunction parseInputInt(str, def) {\n  const parsed = parseInt(str, 10);\n  if (isNaN(parsed)) {\n    return def;\n  }\n  return parsed;\n}\n\n/**\n * Runs the action\n */\nconst action = async () => {\n  const isAllowFailure = core.getBooleanInput(\"allow-failure\");\n  const isComment = core.getBooleanInput(\"comment\");\n  const isCommentDelete = core.getBooleanInput(\"comment-delete\");\n  const isTerragrunt = core.getBooleanInput(\"terragrunt\");\n  const skipFormat = core.getBooleanInput(\"skip-fmt\");\n  const skipPlan = core.getBooleanInput(\"skip-plan\");\n  const skipConftest = core.getBooleanInput(\"skip-conftest\");\n\n  const binary = isTerragrunt ? \"terragrunt\" : \"terraform\";\n  const summarizeBinary = \"tf-summarize\";\n  const commentTitle = core.getInput(\"comment-title\");\n  const directory = core.getInput(\"directory\");\n  const terraformInit = core.getMultilineInput(\"terraform-init\");\n  const conftestChecks = core.getInput(\"conftest-checks\");\n  const token = core.getInput(\"github-token\");\n  const args = core.getInput(\"args\");\n  const octokit = token !== \"false\" ? github.getOctokit(token) : undefined;\n\n  const planCharLimit = core.getInput(\"plan-character-limit\");\n  const conftestCharLimit = core.getInput(\"conftest-character-limit\");\n\n  const commands = [\n    {\n      key: \"init\",\n      exec: `${binary} init -no-color ${\n        terraformInit ? terraformInit.join(\" \") : \"\"\n      }`,\n    },\n    {\n      key: \"validate\",\n      exec: `${binary} validate -no-color`,\n    },\n    {\n      key: \"fmt\",\n      exec: `${binary} fmt --check`,\n    },\n    {\n      key: \"plan\",\n      exec: `${binary} plan -no-color -input=false -out=plan.tfplan ${args}`,\n    },\n    {\n      key: \"show\",\n      exec: `${binary} show -no-color -json plan.tfplan`,\n      depends: \"plan\",\n      output: false,\n    },\n    {\n      key: \"show-json-out\",\n      exec: `${binary} show -no-color -json plan.tfplan > plan.json`,\n      depends: \"plan\",\n      output: false,\n    },\n    {\n      key: \"summary\",\n      exec: `cat plan.json | ${summarizeBinary} -md`,\n      depends: \"show-json-out\",\n    },\n    {\n      key: \"conftest\",\n      depends: \"show-json-out\",\n      exec: `conftest test plan.json --no-color --update ${conftestChecks}`,\n      output: true,\n    },\n  ];\n  let results = {};\n  let isError = false;\n\n  // Validate that directory exists\n  // eslint-disable-next-line security/detect-non-literal-fs-filename\n  if (!fs.existsSync(directory)) {\n    core.setFailed(`Directory ${directory} does not exist`);\n    return;\n  }\n\n  // Validate input\n  if (octokit === undefined && (isComment || isCommentDelete)) {\n    core.setFailed(\"You must pass a GitHub token to comment on PRs\");\n    return;\n  }\n\n  // Exec commands\n  for (let command of commands) {\n    if (skipPlan) {\n      switch (command.key) {\n        case \"plan\":\n        case \"summary\":\n        case \"show\":\n        case \"show-json-out\":\n        case \"conftest\":\n          results[command.key] = { isSuccess: true, output: \"\" };\n          continue;\n      }\n    }\n\n    if (skipFormat && command.key === \"fmt\") {\n      results[command.key] = { isSuccess: true, output: \"\" };\n      continue;\n    }\n\n    if (skipConftest && command.key === \"conftest\") {\n      results[command.key] = { isSuccess: true, output: \"\" };\n      continue;\n    }\n\n    if (!command.depends || results[command.depends].isSuccess) {\n      results[command.key] = execCommand(command, directory);\n    } else {\n      results[command.key] = { isSuccess: false, output: \"\" };\n    }\n    isError = isError || !results[command.key].isSuccess;\n\n    // Check for hashicorp/setup-terraform action's terraform_wrapper output\n    if (results[command.key].output.indexOf(\"::debug::exitcode:\") > -1) {\n      core.setFailed(\n        \"Error: `hashicorp/setup-terraform` must have `terraform_wrapper: false`\",\n      );\n      return;\n    }\n  }\n\n  // Delete previous PR comments\n  if (isCommentDelete) {\n    await deleteComment(octokit, github.context, commentTitle);\n  }\n\n  // Check for changes\n  let changes = {};\n  if (results.show.isSuccess && !skipPlan) {\n    const planJson = JSON.parse(results.show.output);\n    changes = await getPlanChanges(planJson);\n  }\n\n  // Comment on PR if changes or errors\n  if (isComment && (changes.isChanges || isError || skipPlan)) {\n    const planLimit = parseInputInt(planCharLimit, 30000);\n    const conftestLimit = parseInputInt(conftestCharLimit, 2000);\n\n    await addComment(\n      octokit,\n      github.context,\n      commentTitle,\n      results,\n      changes,\n      planLimit,\n      conftestLimit,\n      skipFormat,\n      skipPlan,\n      skipConftest,\n    );\n  }\n\n  if (isError && !isAllowFailure) {\n    let failedCommands = commands\n      .filter((c) => !results[c.key].isSuccess)\n      .map((c) => c.exec);\n    core.setFailed(\n      `The following commands failed:\\n${failedCommands.join(\"\\n\")}`,\n    );\n  }\n};\n\nmodule.exports = {\n  action: action,\n};\n","\"use strict\";\n/* eslint security/detect-child-process: \"off\" */\n\nconst proc = require(\"child_process\");\n\n/**\n * Executes a command in a given directory\n * @param {Object} command The command to execute\n * @param {String} directory The directory to execute the command in\n * @returns {Object} Results object with the command output and if the command was successful\n */\nconst execCommand = (command, directory) => {\n  let output,\n    exitCode = 0;\n\n  try {\n    console.log(\"🧪 \\x1b[36m%s\\x1b[0m\\n\", command.exec);\n    output = proc\n      .execSync(command.exec, {\n        cwd: directory,\n        maxBuffer: 1024 * 10000,\n      })\n      .toString(\"utf8\");\n  } catch (error) {\n    exitCode = error.status;\n    output = \"\";\n    output += error.stdout ? error.stdout.toString(\"utf8\") : \"\";\n    output += error.stderr ? error.stderr.toString(\"utf8\") : \"\";\n    console.log(`Command failed: exit code ${exitCode}`);\n  }\n\n  if (command.output !== false) {\n    console.log(output);\n  }\n\n  return {\n    isSuccess: exitCode === 0,\n    output: output,\n  };\n};\n\nmodule.exports = {\n  execCommand: execCommand,\n};\n","\"use strict\";\n\nconst nunjucks = require(\"nunjucks\");\nconst commentTemplate = `## {{ title }}\n**{{ \"✅\" if results.init.isSuccess else \"❌\" }} &nbsp; Terraform Init:** \\`{{ \"success\" if results.init.isSuccess else \"failed\" }}\\`\n**{{ \"✅\" if results.validate.isSuccess else \"❌\" }} &nbsp; Terraform Validate:** \\`{{ \"success\" if results.validate.isSuccess else \"failed\" }}\\`\n{% if not skipFormat -%}\n**{{ \"✅\" if results.fmt.isSuccess else \"❌\" }} &nbsp; Terraform Format:** \\`{{ \"success\" if results.fmt.isSuccess else \"failed\" }}\\`\n{% endif -%}\n{% if not skipPlan -%}\n**{{ \"✅\" if results.plan.isSuccess else \"❌\" }} &nbsp; Terraform Plan:** \\`{{ \"success\" if results.plan.isSuccess else \"failed\" }}\\`\n{% if not skipConftest -%}\n**{{ \"✅\" if results.conftest.isSuccess else \"❌\" }} &nbsp; Conftest:** \\`{{ \"success\" if results.conftest.isSuccess else \"failed\" }}\\` \n\n{% endif -%}\n{% endif -%}\n{% if not results.init.isSuccess -%}\n\n<details>\n<summary>Show Init results</summary>\n\n\\`\\`\\`sh\n{{ results.init.output }}\n\\`\\`\\`\n\n</details>\n\n{% endif -%}\n{% if not results.validate.isSuccess -%}\n<details>\n<summary>Show Validate results</summary>\n\n\\`\\`\\`sh\n{{ results.validate.output }}\n\\`\\`\\`\n\n</details>\n\n{% endif -%}\n{% if not results.fmt.isSuccess and format|length -%}\n**🧹 &nbsp; Format:** run \\`terraform fmt\\` to fix the following: \n\\`\\`\\`sh\n{{ format }}\n\\`\\`\\`\n{% endif -%}\n\n{% if not skipPlan -%}\n{% if changes.isDeletes -%}\n**⚠️ &nbsp; Warning:** resources will be destroyed by this change!\n{% endif -%}\n\n{% if changes.isChanges -%}\n\\`\\`\\`terraform\nPlan: {{ changesLine }}\n\\`\\`\\`\n\n<details>\n<summary>Show summary</summary>\n\n{{ results.summary.output }}\n\n</details>\n\n\n{% endif -%}\n\n{% if plan|length >= planLimit -%}\n**✂ &nbsp; Warning:** plan has been truncated! See the [full plan in the logs]({{ runLink }}).\n{% endif -%}\n<details>\n<summary>Show plan</summary>\n\n\\`\\`\\`terraform\n{{ plan|safe|truncate(planLimit) }}\n\\`\\`\\`\n\n</details>\n\n{% if not skipConftest and results.conftest.output -%}\n<details>\n<summary>Show Conftest results</summary>\n\n\\`\\`\\`sh\n{{ results.conftest.output|safe|truncate(conftestLimit) }}\n\\`\\`\\`\n\n</details>\n{% endif -%}\n{% endif -%}`;\n\n/**\n *\n * @param {*} resources\n * @returns\n */\nconst generateChangesLine = (changes) => {\n  if (Object.keys(changes).length === 0) {\n    return \"\";\n  }\n  const resources = changes.resources;\n  if (resources.import === 0) {\n    return `${resources.create} to add, ${resources.update} to change, ${resources.delete} to destroy`;\n  } else {\n    return `${resources.import} to import, ${resources.create} to add, ${resources.update} to change, ${resources.delete} to destroy`;\n  }\n};\n\n/**\n * Adds a comment to the Pull Request with the Terraform plan changes\n * and result of the format/validate checks.\n * @param {Object} octokit GitHub API object\n * @param {Object} context GitHub context for the workflow run\n * @param {String} title Comment heading\n * @param {Object} results Results for all the Terraform commands\n * @param {Object} changes Resource and output changes for the plan\n * @param {number} planLimit the number of characters to render\n * @param {number} conftestPlanLimit the nubmer of characters to render\n * @param {boolean} skipFormat Skip runnting terraform fmt check\n * @param {boolean} skipPlan Skip the rendering of the plan output\n */\nconst addComment = async (\n  octokit,\n  context,\n  title,\n  results,\n  changes,\n  planLimit,\n  conftestLimit,\n  skipFormat,\n  skipPlan,\n  skipConftest,\n) => {\n  const format = cleanFormatOutput(results.fmt.output);\n  const plan = skipPlan ? \"\" : removePlanRefresh(results.plan.output);\n  const comment = nunjucks.renderString(commentTemplate, {\n    changes: changes,\n    changesLine: generateChangesLine(changes),\n    plan: plan,\n    format: format,\n    results: results,\n    title: title,\n    planLimit: planLimit,\n    conftestLimit: conftestLimit,\n    skipFormat: skipFormat,\n    skipPlan: skipPlan,\n    skipConftest: skipConftest,\n    runLink: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,\n  });\n  await octokit.rest.issues.createComment({\n    ...context.repo,\n    issue_number: context.payload.pull_request.number,\n    body: comment,\n  });\n};\n\n/**\n * Deletes a comment made by the action on the PR.\n * @param {Object} octokit GitHub API object\n * @param {Object} context GitHub context for the workflow run\n * @param {String} title Heading of the comment to delete\n */\nconst deleteComment = async (octokit, context, title) => {\n  // Get existing comments.\n  const { data: comments } = await octokit.rest.issues.listComments({\n    ...context.repo,\n    issue_number: context.payload.pull_request.number,\n  });\n\n  // Find the bot's comment\n  const comment = comments.find(\n    (comment) =>\n      comment.user.type === \"Bot\" && comment.body.indexOf(title) > -1,\n  );\n  if (comment) {\n    console.log(`Deleting comment '${title}: ${comment.id}'`);\n    await octokit.rest.issues.deleteComment({\n      ...context.repo,\n      comment_id: comment.id,\n    });\n  }\n};\n\n/**\n * Removes the Terraform refresh output from a plan.\n * @param {String} plan Terraform plan output\n * @returns {String} Terraform plan with the refresh output stripped\n */\nconst removePlanRefresh = (plan) => {\n  const startTokens = [\n    \"No changes. Infrastructure is up-to-date\",\n    \"Resource actions are indicated with the following symbols\",\n    \"Changes to Outputs\",\n  ];\n\n  // This will only strip the first refresh token it finds in the plan ouput\n  for (let token of startTokens) {\n    let index = plan.indexOf(token);\n    if (index > -1) {\n      plan = plan.substring(index);\n      break;\n    }\n  }\n  return plan;\n};\n\n/**\n * Remove all lines from a block text that doesn't end with *.tf.\n * This is used to remove errors from the terrform fmt output.\n * @param {String} format Output from the terraform fmt\n * @returns Terraform fmt output with only *.tf filenames.\n */\nconst cleanFormatOutput = (format) => {\n  return format\n    .split(\"\\n\")\n    .filter((line) => line.match(/^.*\\.tf$/))\n    .join(\"\\n\");\n};\n\nmodule.exports = {\n  addComment: addComment,\n  cleanFormatOutput: cleanFormatOutput,\n  deleteComment: deleteComment,\n  removeRefreshOutput: removePlanRefresh,\n  commentTemplate: commentTemplate,\n};\n","const noChangesFound = (resources, outputs) => {\n  const noChangeResource = () =>\n    resources.create === 0 &&\n    resources.update === 0 &&\n    resources.delete === 0 &&\n    resources.import === 0;\n\n  const noChangeOutput = () =>\n    outputs.create === 0 && outputs.update === 0 && outputs.delete === 0;\n\n  return noChangeResource() && noChangeOutput();\n};\n\nconst countImports = (tfplan) => {\n  const imports = tfplan.resource_changes.filter((res) => {\n    return res.change.importing !== undefined;\n  });\n  return imports.length;\n};\n\nconst countResourceChanges = (tfPlan, action) => {\n  const actions = tfPlan.resource_changes.filter((res) =>\n    res.change.actions.includes(action),\n  );\n  return actions.length;\n};\n\nconst countOutputChanges = (tfPlan, action) => {\n  let count = 0;\n  for (let prop in tfPlan.output_changes) {\n    // This is safe as prop comes from the list of props on the object\n    // eslint-disable-next-line security/detect-object-injection\n    if (tfPlan.output_changes[prop].actions.includes(action)) {\n      count = count + 1;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {Object} planJson Terraform plan JSON object\n * @returns {Object} Resource and output changes in the tfplan\n */\nconst getPlanChanges = async (planJson) => {\n  let changes;\n\n  let resources = {\n    create: 0,\n    update: 0,\n    delete: 0,\n    import: 0,\n  };\n\n  let outputs = {\n    create: 0,\n    update: 0,\n    delete: 0,\n  };\n  if (planJson.resource_changes != undefined) {\n    resources = {\n      create: countResourceChanges(planJson, \"create\"),\n      update: countResourceChanges(planJson, \"update\"),\n      delete: countResourceChanges(planJson, \"delete\"),\n      import: countImports(planJson),\n    };\n  }\n\n  if (planJson.output_changes != undefined) {\n    outputs = {\n      create: countOutputChanges(planJson, \"create\"),\n      update: countOutputChanges(planJson, \"update\"),\n      delete: countOutputChanges(planJson, \"delete\"),\n    };\n  }\n\n  const noChanges = noChangesFound(resources, outputs);\n\n  changes = {\n    isChanges: !noChanges,\n    isDeletes: resources.delete > 0,\n    resources: resources,\n    ouputs: outputs,\n  };\n\n  return changes;\n};\n\nmodule.exports = {\n  getPlanChanges: getPlanChanges,\n};\n",null,"module.exports = require(\"child_process\");","module.exports = require(\"fs\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","\"use strict\";\n\nconst core = require(\"@actions/core\");\nconst { action } = require(\"./action.js\");\n\n/**\n * Logs an error and sets the action as failed.\n * @param {String} err Error message\n */\nconst handleError = (err) => {\n  console.error(err);\n  core.setFailed(`Unhandled error: ${err}`);\n};\n\nprocess.on(\"unhandledRejection\", handleError);\naction().catch(handleError);\n"],"names":[],"sourceRoot":""}